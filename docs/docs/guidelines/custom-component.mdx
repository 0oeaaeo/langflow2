---
description: Custom Components
hide_table_of_contents: true
---

import ZoomableImage from "/src/theme/ZoomableImage.js";
import Admonition from "@theme/Admonition";

# Custom Components

In Langflow, a Custom Component is a special component type that allows users to extend the platform's functionality by creating their own reusable and configurable components.

A Custom Component is created from a user-defined Python script that uses the _`CustomComponent`_ class provided by the Langflow library. These components can be as simple as a basic function that takes and returns a string or as complex as a combination of multiple sub-components and API calls.

Let's take a look at the basic rules and features. Then we'll go over an example.

## TL;DR

- Create a class that inherits from _`CustomComponent`_ and contains a _`build`_ method.
- Use arguments with [Type Annotations (or Type Hints)](https://docs.python.org/3/library/typing.html) of the _`build`_ method to create component fields.
- Use the _`build_config`_ method to customize how these fields look and behave.

Here is an example:
<div style={{
        display: "flex",
        justifyContent: "center",
    }}>
    <CH.Code linuNumbers={false}>

    ```python
    from langflow import CustomComponent
    from langchain.schema import Document

    class DocumentProcessor(CustomComponent):
        display_name = "Document Processor"
        description = "This component processes a document"

        def build_config(self) -> dict:
            options = ["Uppercase", "Lowercase", "Titlecase"]
            return {
                "function": {"options": options,
                        "value": options[0]}}

        def build(self, document: Document, function: str) -> Document:
            page_content = document.page_content
            if function == "Uppercase":
                page_content = page_content.upper()
            elif function == "Lowercase":
                page_content = page_content.lower()
            elif function == "Titlecase":
                page_content = page_content.title()
            return Document(page_content=page_content)
    ```

    </CH.Code>

    <ZoomableImage
    alt="Document Processor Component"
    sources={{
        light: "img/document_processor.png",
    }}
    style={{
        width: "40%",
        margin: "0 auto",
        display: "flex",
        justifyContent: "center",
    }}
    />
</div>

<Admonition type="tip">
  Check out [FlowRunner Component](../examples/flow-runner) for a more complex
  example.
</Admonition>

---

## Rules

The Python script for every Custom Component should follow a set of rules. Let's go over them one by one:

<CH.Scrollycoding rows={20} className={""}>

### Rule 1

The script must contain a **single class** that inherits from _`CustomComponent`_.

```python
from langflow import CustomComponent
from langchain.schema import Document

class MyComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    def build(self, document: Document, function: str) -> Document:
        ...
```

---

### Rule 2

This class requires a _`build`_ method used to run the component and define its fields.

```python
from langflow import CustomComponent
from langchain.schema import Document

class MyComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    # focus
    # mark
    def build(self) -> Document:
        ...
```

---

The [Return Type Annotation](https://docs.python.org/3/library/typing.html) of the _`build`_ method defines the component type (e.g., Chain, BaseLLM, or basic Python types). Check out all supported types in the [component reference](../components/custom).

```python
from langflow import CustomComponent
from langchain.schema import Document

class MyComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    # focus[20:31]
    # mark
    def build(self) -> Document:
        ...
```

---

```python
from langflow import CustomComponent
from langchain.schema import Document

class MyComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    def build(self) -> Document:
        ...
```

### Rule 3

The class can have a [_`build_config`_](focus://8) method, which defines configuration fields for the component. The [_`build_config`_](focus://8) method should always return a dictionary with specific keys representing the field names and their corresponding configurations. It must follow the format described below:

- Top-level keys are field names.
- Their values are also of type _`dict`_. They specify the behavior of the generated fields.

Check out the [component reference](../components/custom) for more details on the available field configurations.

---

```python
from langflow import CustomComponent
from langchain.schema import Document

class MyComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    def build(self) -> Document:
        ...
```

## Example

Let's create a custom component that processes a document (_`langchain.schema.Document`_) using a simple function.

---

### Pick a display name

To start, let's choose a name for our component by adding a _`display_name`_ attribute. This name will appear on the canvas. The name of the class is not relevant, but let's call it _`DocumentProcessor`_.

```python
from langflow import CustomComponent
from langchain.schema import Document

# focus
class DocumentProcessor(CustomComponent):
    # focus
    display_name = "Document Processor"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    def build(self) -> Document:
        ...
```

---

### Write a description

We can also write a description for it using a _`description`_ attribute.

```python
from langflow import CustomComponent
from langchain.schema import Document

class DocumentProcessor(CustomComponent):
    display_name = "Document Processor"
    description = "This component processes a document"

    def build_config(self) -> dict:
        ...

    def build(self) -> Document:
        ...
```

---

```python
from langflow import CustomComponent
from langchain.schema import Document

class DocumentProcessor(CustomComponent):
    display_name = "Document Processor"
    description = "This component processes a document"

    def build_config(self) -> dict:
        ...

    def build(self, document: Document, function: str) -> Document:
        page_content = document.page_content
        if function == "Uppercase":
            page_content = page_content.upper()
        elif function == "Lowercase":
            page_content = page_content.lower()
        elif function == "Titlecase":
            page_content = page_content.title()
        return Document(page_content=page_content)
```

### Add the build method

Here, the build method takes two input parameters: _`document`_, representing the input document to be processed, and _`function`_, a string representing the selected text transformation to be applied (either "Uppercase," "Lowercase," or "Titlecase"). The method processes the text content of the input Document based on the selected function. 

The return type is _`Document`_.

---

### Customize the component fields

The _`build_config`_ method is here defined to customize the component fields.

- _`options`_ determines that the field will be a dropdown menu. The list values and field type must be _`str`_.
- _`value`_ is the default option of the dropdown menu.
- _`display_name`_ is the name of the field to be displayed.

```python
from langflow import CustomComponent
from langchain.schema import Document

class DocumentProcessor(CustomComponent):
    display_name = "Document Processor"
    description = "This component processes a document"

    def build_config(self) -> dict:
        options = ["Uppercase", "Lowercase", "Titlecase"]
        return {
            "function": {"options": options,
                     "value": options[0],
                     "display_name": "Function"
                        },
            "document": {"display_name": "Document"}
                }

    def build(self, document: Document, function: str) -> Document:
        page_content = document.page_content
        if function == "Uppercase":
            page_content = page_content.upper()
        elif function == "Lowercase":
            page_content = page_content.lower()
        elif function == "Titlecase":
            page_content = page_content.title()
        return Document(page_content=page_content)
```

</CH.Scrollycoding>


All done! This is what our script and brand-new custom component look like:

<div style={{
        display: "flex",
        justifyContent: "center",
    }}>

    <ZoomableImage
    alt="Document Processor Code"
    sources={{
        light: "img/document_processor_code.png",
    }}
    style={{
        maxWidth: "100%",
        margin: "0 auto",
        display: "flex",
        justifyContent: "center",
    }}
/>



    <ZoomableImage
    alt="Document Processor Component"
    sources={{
        light: "img/document_processor.png",
    }}
    style={{
        width: "40%",
        margin: "0 auto",
        display: "flex",
        justifyContent: "center",
    }}
    />
</div>


<Admonition type="tip" label="Tip">

To reproduce this example using Langflow's native components, you could create a Tool and ask an Agent to use it.

</Admonition>