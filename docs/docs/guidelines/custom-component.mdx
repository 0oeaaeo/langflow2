---
description: Custom Components
hide_table_of_contents: true
---

import ZoomableImage from "/src/theme/ZoomableImage.js";
import Admonition from "@theme/Admonition";

# Custom Components

In Langflow, a Custom Component is a special component type that allows users to extend the functionality of the platform by creating their own reusable and configurable components.

A Custom Component is created from a user-defined Python script that uses the _`CustomComponent`_ class provided by the Langflow library. These components can be as simple as a basic function that takes and returns a string or as complex as a combination of multiple sub-components and API calls.

Let's take a look at the basic rules and features, then we'll go over an example.

## TL;DR

- Create a class that inherits from _`CustomComponent`_ and contains a _`build`_ method.
- Use arguments with [Type Annotations (or Type Hints)](https://docs.python.org/3/library/typing.html) of the _`build`_ method to create component fields.
- Use the _`build_config`_ method to customize these fields look and behave.

Here is an example:

<CH.Code linuNumbers={false}>

```python
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Best Component"
    description = "This is the best component ever"

    def build_config(self) -> dict:
        cool_tool_names = ["Cool Tool",
                           "Cooler Tool",
                           "Coolest Tool"]
        return {
            "description": {"multiline": True},
            "name": {"is_list": True,
                     "options": cool_tool_names}}

    def build(self, name: str, description: str, chain: Chain):
        return Tool(name=name,
                    description=description,
                    func=chain.run)
```

</CH.Code>

---

## Rules

The Python script for every Custom Component should follow a set of rules. Let's go over them, one by one:

<CH.Scrollycoding rows={20} className={""}>

### Rule 1

The script must contain a **single class** that inherits from _`CustomComponent`_.

```python
# focus
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

# focus
class BestComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    def build(self):
        ...
```

---

### Rule 2

This class requires a _`build`_ method, which is used to run the component and defines its fields.

```python
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    # focus[1:20]
    def build(self) -> Tool:
        ...
```

---

The [Return Type Annotation](https://docs.python.org/3/library/typing.html) of the _`build`_ method defines the component type (e.g., Chain, BaseLLM or basic Python types). Check out all supported types in the [component reference](../components/custom).

```python
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    def build_config(self) -> dict:
        ...

    # focus[21:30]
    def build(self) -> Tool:
        ...
```

---

```python
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Custom Component"
    description = "This is a custom component"

    # focus
    def build_config(self) -> dict:
        ...

    def build(self) -> Tool:
        ...
```

### Rule 3

The class can have a [_`build_config`_](focus://11:19) method, which is used to define configuration fields for the component. The _`build_config`_ method should always return a dictionary with specific keys representing the field names and their corresponding configurations. It must follow the format described below:

- Top-level keys are field names.
- Their values are also of type _`dict`_. They specify the behavior of the generated fields.

Check out the [component reference](../components/custom) for more details on the available field configurations.

---

```python
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    # focus
    def build_config(self) -> dict:
        ...

    def build(self) -> Tool:
        ...
```

## Example

Let's create a custom component that will convert a chain into a tool. It should receive as input a chain component, a tool name, and a description (for an agent to access it).

<Admonition type="info" label="Tip">

This is also possible with Langflow native components. It's being reproduced here with a custom component for demonstration purposes.

</Admonition>

---

### Pick a display name

First, let's choose a name for our component by adding a _`display_name`_ attribute. This is the component name to be displayed in the canvas.

```python focus=9
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Best Component"

    def build_config(self) -> dict:
        ...

    def build(self) -> Tool:
        ...
```

---

### Write a description

We can also write a description for it using the _`description`_ attribute.

```python focus=10
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Best Component"
    description = "This is the best component ever"

    def build_config(self) -> dict:
        ...

    def build(self) -> Tool:
        ...
```

---

### Customize the fields

The _`build_config`_ method will be used to configure the fields of the component.

- _`multiline`_ allows editing text in an expansive text editor.

- _`is_list`_ allows an input field to contain multiple values. When paired with _`options`_, it will transform it into a dropdown menu.

```python focus=12:19
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Best Component"
    description = "This is the best component ever"

    def build_config(self) -> dict:
        cool_tool_names = ["Summarizer",
                           "Enhancer",
                           "Translator"]
        return {
            "description": {"multiline": True},
            "name": {"is_list": True,
                     "options": cool_tool_names}}

    def build(self) -> Tool:
        ...
```

---

```python focus=21:25
from langflow import CustomComponent
from langchain.chains import LLMChain
from langchain.chains.base import Chain
from langchain import PromptTemplate
from langchain.llms.base import BaseLLM
from langchain import Tool

class BestComponent(CustomComponent):
    display_name = "Best Component"
    description = "This is the best component ever"

    def build_config(self) -> dict:
        cool_tool_names = ["Cool Tool",
                           "Cooler Tool",
                           "Coolest Tool"]
        return {
            "description": {"multiline": True},
            "name": {"is_list": True,
                     "options": cool_tool_names}}

    def build(self, name: str, description: str,
    chain: Chain) -> Tool:
        return Tool(name=name,
                    description=description,
                    func=chain.run)
```

### Add the build method

The parameters used are:

- name is a string
- description is a string
- chain is a Chain
- The return type is Tool

We then instantiate a Tool and return it.

</CH.Scrollycoding>

In Langflow, this is how our script looks like:

<div
  style={{ marginBottom: "20px", display: "flex", justifyContent: "center" }}
>
  <ZoomableImage
    alt="Docusaurus themed image"
    sources={{
      light: "img/new_langflow2.gif",
    }}
  />
</div>

And here is our brand new custom component:

<div
  style={{ marginBottom: "20px", display: "flex", justifyContent: "center" }}
>
  <ZoomableImage
    alt="Docusaurus themed image"
    sources={{
      light: "img/new_langflow2.gif",
    }}
  />
</div>

## FlowRunner Example

Now let's see how to create a component that runs other flows.

<CH.Scrollycoding rows={20} className={""}>

```python
from langflow.interface.custom.custom_component import CustomComponent

class MyComponent(CustomComponent):
    display_name = "Custom Component"

    def build_config(self):
        ...

    def build(self):
        ...

```

This is the basic structure of a custom component.

---

```python
from langflow.interface.custom.custom_component import CustomComponent

# focus
class FlowRunner(CustomComponent):
    # focus
    display_name = "Flow Runner"
    # focus
    description = "Run other flows"

    def build_config(self):
        ...

    def build(self):
        ...

```

So, let's start by adding the _`display_name`_ and a _`description`_.

---

```python
from langflow.interface.custom.custom_component import CustomComponent
# focus
from langchain.schema import Document


class FlowRunner(CustomComponent):

    display_name = "Flow Runner"

    description = "Run other flows"

    def build_config(self):
        ...

    def build(self):
        ...

```

Now let's import Document from the schema module, which will be our return type for the _`build`_ method.

---

```python
from langflow.interface.custom.custom_component import CustomComponent
from langchain.schema import Document

class FlowRunner(CustomComponent):
    display_name = "Flow Runner"
    description = "Run other flows using a document as input."

    def build_config(self):
        ...

    # focus
    def build(self, flow_name: str, document: Document) -> Document:
        ...

```

Let's add the [parameters](focus://11[20:55]) and the [return type](focus://11[60:69]) to the _`build`_ method.

---

```python
from langflow.interface.custom.custom_component import CustomComponent
from langchain.schema import Document


class FlowRunner(CustomComponent):

    display_name = "Flow Runner"

    description = "Run other flows using a document as input."

    def build_config(self):
        ...

    def build(self, flow_name: str, document: Document) -> Document:
        # focus
        # List the flows
        # focus
        flows = self.list_flows()

```

---

```python
from langflow.interface.custom.custom_component import CustomComponent
from langchain.schema import Document


class FlowRunner(CustomComponent):

    display_name = "Flow Runner"

    description = "Run other flows using a document as input."

    def build_config(self):
        ...

    def build(self, flow_name: str, document: Document) -> Document:
        # List the flows
        flows = self.list_flows()
        # focus
        # Get the flow that matches the selected name
        # focus
        flow = next(filter(lambda f: f.name == flow_name, flows))

```

With the _`list_flows`_ method, we can get a list of all the flows in the collection.

We can then get the flow that matches the selected name.

---

```python
from langflow.interface.custom.custom_component import CustomComponent
from langchain.schema import Document


class FlowRunner(CustomComponent):

    display_name = "Flow Runner"

    description = "Run other flows using a document as input."

    def build_config(self):
        ...

    def build(self, flow_name: str, document: Document) -> Document:
        # List the flows
        flows = self.list_flows()
        # Get the flow that matches the selected name
        flow = next(filter(lambda f: f.name == flow_name, flows))
        # focus
        # Load the flow
        # focus
        tweaks = {}
        # focus
        flow = self.load_flow(flow.id, tweaks)

```

---

```python
from langflow.interface.custom.custom_component import CustomComponent
from langchain.schema import Document


class FlowRunner(CustomComponent):

    display_name = "Flow Runner"

    description = "Run other flows using a document as input."

    def build_config(self):
        ...

    def build(self, flow_name: str, document: Document) -> Document:
        # List the flows
        flows = self.list_flows()
        # Get the flow that matches the selected name
        flow = next(filter(lambda f: f.name == flow_name, flows))
        # Load the flow
        tweaks = {}
        flow = self.load_flow(flow.id, tweaks)
        # focus
        # Get the page_content from the document
        # focus
        page_content = document.page_content
```

---

```python
from langflow.interface.custom.custom_component import CustomComponent
from langchain.schema import Document


class FlowRunner(CustomComponent):

    display_name = "Flow Runner"

    description = "Run other flows using a document as input."

    def build_config(self):
        ...

    def build(self, flow_name: str, document: Document) -> Document:
        # List the flows
        flows = self.list_flows()
        # Get the flow that matches the selected name
        flow = next(filter(lambda f: f.name == flow_name, flows))
        # Load the flow
        tweaks = {}
        flow = self.load_flow(flow.id, tweaks)
        # Get the page_content from the document
        page_content = document.page_content
        # Use it in the flow
        result = flow(page_content)
        return Document(page_content=str(result))
```

---

</CH.Scrollycoding>
